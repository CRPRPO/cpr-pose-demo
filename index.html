<!DOCTYPE html>
<html>
<head>
  <title>CPR åµæ¸¬ç³»çµ± V5.6</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
    }
    video {
      transform: scaleX(-1); /* é¡åƒå½±ç‰‡ */
      z-index: 0;
    }
    canvas {
      z-index: 1;
    }
    #startBtn {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5em;
      padding: 20px 30px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      z-index: 2;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
  <button id="startBtn">é–‹å•Ÿé¡é ­</button>
  <div id="camSwitch" style="
  position:absolute; top:12px; right:12px; z-index:3; display:flex; gap:8px;">
  <button data-mode="user" style="padding:8px 12px; border-radius:8px;">å‰é¡é ­</button>
  <button data-mode="environment" style="padding:8px 12px; border-radius:8px;">å¾Œé¡é ­</button>
</div>


<!-- MediaPipe Pose + Camera Utilitiesï¼ˆCDNï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
  // æª¢æŸ¥å¤–éƒ¨å¥—ä»¶æ˜¯å¦è¼‰å…¥
  if (!window.Pose || !window.Camera) {
    console.error("MediaPipe å°šæœªè¼‰å…¥");
  }

  const video   = document.getElementById("video");
  const canvas  = document.getElementById("canvas");
  const ctx     = canvas.getContext("2d");
  const startBtn= document.getElementById("startBtn");

  // ---- MediaPipe ç´¢å¼• ----
  const L_SHOULDER = 11, R_SHOULDER = 12;
  const L_ELBOW    = 13, R_ELBOW    = 14;
  const L_WRIST    = 15, R_WRIST    = 16;

  // ---- å¹³æ»‘åƒæ•¸ ----
  const smoothStore = {};
  const SMOOTH_ALPHA = 0.6;
  function smoothPoint(idx, raw, w, h) {
    if (!raw) return null;
    const x = raw.x * w, y = raw.y * h;
    const prev = smoothStore[idx];
    smoothStore[idx] = prev
      ? { x: SMOOTH_ALPHA * prev.x + (1 - SMOOTH_ALPHA) * x,
          y: SMOOTH_ALPHA * prev.y + (1 - SMOOTH_ALPHA) * y }
      : { x, y };
    return smoothStore[idx];
  }

  function drawCircle(p, r, color) {
    if (!p) return;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  }
  function drawLine(a, b, width, color) {
    if (!a || !b) return;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    ctx.stroke();
  }

  let pose = null;
  let camera = null;

  async function initPose() {
    console.log("Pose?", window.Pose, "Camera?", window.Camera);
    
    pose = new window.Pose({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
});
    
    pose.setOptions({
      modelComplexity: 0,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });
    pose.onResults(onPoseResults);

    // Camera Utils æœƒè‡ªå·±é–‹é¡èˆ‡å–æµ
    camera = new Camera(video, {
      onFrame: async () => { await pose.send({ image: video }); },
      width: 640,
      height: 480,
    });

    // ç­‰åˆ° video æœ‰å°ºå¯¸å¾ŒæŠŠ canvas åŒæ­¥
    video.addEventListener("loadeddata", () => {
      if (video.videoWidth && video.videoHeight) {
        canvas.width  = video.videoWidth;
        canvas.height = video.videoHeight;
      }
    }, { once: true });

    await camera.start();
  }

  function onPoseResults(results) {
    const landmarks = results.poseLandmarks;
    if (!landmarks) return;

    const w = canvas.width  = video.videoWidth  || canvas.width;
    const h = canvas.height = video.videoHeight || canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, w, h);

    // é¡åƒåº§æ¨™ï¼Œå’Œä½ çš„é¡åƒå½±ç‰‡ä¸€è‡´
    ctx.translate(w, 0);
    ctx.scale(-1, 1);

    const ls = smoothPoint(L_SHOULDER, landmarks[L_SHOULDER], w, h);
    const rs = smoothPoint(R_SHOULDER, landmarks[R_SHOULDER], w, h);
    const le = smoothPoint(L_ELBOW,    landmarks[L_ELBOW],    w, h);
    const re = smoothPoint(R_ELBOW,    landmarks[R_ELBOW],    w, h);
    const lw = smoothPoint(L_WRIST,    landmarks[L_WRIST],    w, h);
    const rw = smoothPoint(R_WRIST,    landmarks[R_WRIST],    w, h);

    // é»
    drawCircle(ls, 6, "#00BFFF");
    drawCircle(rs, 6, "#00BFFF");
    drawCircle(le, 5, "#FF4D4F");
    drawCircle(re, 5, "#FF4D4F");
    drawCircle(lw, 5, "#FF4D4F");
    drawCircle(rw, 5, "#FF4D4F");

    // ç·šï¼šè‚©è†€è—ã€æ‰‹è‡‚ç´…
    drawLine(ls, rs, 6, "#1E90FF");
    drawLine(ls, le, 6, "#FF3333"); drawLine(le, lw, 6, "#FF3333");
    drawLine(rs, re, 6, "#FF3333"); drawLine(re, rw, 6, "#FF3333");

    ctx.restore();

    // é€™è£¡ç•«éé¡åƒ HUDï¼ˆè‹¥æœ‰ï¼‰
    // ctx.fillStyle = "#fff";
    // ctx.font = "bold 28px sans-serif";
    // ctx.fillText("å³æ™‚é€Ÿç‡ï¼šxxx æ¬¡/åˆ†", 20, 40);
  }

  // åªåšä¸€ä»¶äº‹ï¼šæŒ‰ä¸‹å»å•Ÿå‹• Pose/Camera
  startBtn.addEventListener("click", async () => {
    try {
      await initPose();
      const camSwitch = document.getElementById("camSwitch");
let currentFacing = "user";   // é è¨­å‰é¡é ­

async function initPose(facingMode = "user") {
  // è‹¥å·²å­˜åœ¨ cameraï¼Œå…ˆåœæ‰
  if (camera && camera.stop) {
    try { camera.stop(); } catch (_) {}
  }

  if (!pose) {
    pose = new window.Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
    });
    pose.setOptions({
      modelComplexity: 0,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });
    pose.onResults(onPoseResults);
  }

  // ç”¨ Camera Utilsï¼Œå˜—è©¦å¸¶å…¥ facingMode
  camera = new Camera(video, {
    onFrame: async () => { await pose.send({ image: video }); },
    width: 640,
    height: 480,
    facingMode,              // ğŸ‘ˆ é€™è¡Œè®“æ‰‹æ©Ÿ/å¹³æ¿é¸å‰/å¾Œé¡é ­
  });

  // ç­‰åˆ° video æœ‰å°ºå¯¸å¾ŒæŠŠ canvas åŒæ­¥
  video.addEventListener("loadeddata", () => {
    if (video.videoWidth && video.videoHeight) {
      canvas.width  = video.videoWidth;
      canvas.height = video.videoHeight;
    }
  }, { once: true });

  await camera.start();
  currentFacing = facingMode;
}

startBtn.addEventListener("click", async () => {
  try {
    await initPose(currentFacing);
    startBtn.style.display = "none";
  } catch (err) {
    alert("âš ï¸ ç„¡æ³•å•Ÿç”¨é¡é ­ï¼š" + err.message);
    console.error(err);
  }
});

// é»é¸åˆ‡æ›é¡é ­ï¼ˆè‹¥å°šæœªå•Ÿå‹•ï¼Œä¹Ÿåªæ˜¯åˆ‡æ›é è¨­ï¼‰
camSwitch.addEventListener("click", async (e) => {
  const btn = e.target.closest("button[data-mode]");
  if (!btn) return;
  const mode = btn.getAttribute("data-mode"); // "user" or "environment"
  currentFacing = mode;
  if (video.srcObject || (camera && camera.start)) {
    // å·²å•Ÿå‹• â†’ ç›´æ¥åˆ‡æ›
    try { await initPose(mode); } catch (err) { console.error(err); }
  }
});

    } catch (err) {
      alert("âš ï¸ ç„¡æ³•å•Ÿç”¨é¡é ­ï¼š" + err.message);
      console.error(err);
    }
  });
</script>

</body>
</html>
