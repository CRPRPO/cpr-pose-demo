<!DOCTYPE html>
<html>
<head>
  <title>CPR 偵測系統 V5.11</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;  /* 用 100dvh 避免手機瀏覽器位址列收展造成的高度誤差 */
      height: 100dvh;          /* 避免手機瀏覽器地址列影響高度 */
      object-fit: cover;       /* ← 讓兩者等比填滿，避免黑邊錯位 */
    }
    .mirror {                   /* 需要鏡像時加上這個 class */
      transform: scaleX(-1);
      transform-origin: center;
    }

    /* 新增：左上角 HUD（DOM，不再用 canvas 寫字） */
    /* DOM HUD（用它顯示速率/次數） */
    #hud {
      position: absolute;
      top: 0; left: 0;
      padding: calc(env(safe-area-inset-top, 0px) + 12px) 16px 12px 16px;
      z-index: 4;
      display: grid;
      gap: 6px;
      background: rgba(0,0,0,0.55);  /* 半透明底 */
      border-bottom-right-radius: 14px;
      /* RWD 字級：手機不太小、桌機不太大 */
      font: bold clamp(18px, 2.4vw, 36px) / 1.1 sans-serif;
      color: #fff;
      pointer-events: none;     /* 點不到 HUD，避免擋到切換鈕 */
    }
    #hud .row { white-space: nowrap; }
    #hud .val { margin-left: 6px; }

    /* 橫式時把 HUD 移到右上，避免被畫面內容擠到 */
    @media (orientation: landscape) {
      #hud {
        left: auto;
        right: 12px;
      }
    }

    canvas { z-index: 1; }
    #startBtn {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5em;
      padding: 20px 30px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      z-index: 2;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="hud">
    <div class="row">即時速率：<span id="bpmNow">--</span> 次/分</div>
    <div class="row">平均速率：<span id="bpmAvg">--</span> 次/分</div>
    <div class="row">按壓次數：<span id="pressCnt">0</span> 次</div>
  </div>

  <button id="startBtn">開啟鏡頭</button>

  <div id="camSwitch" style="position:absolute; top:12px; right:12px; z-index:3; display:flex; gap:8px;">
    <button data-mode="user" style="padding:8px 12px; border-radius:8px;">前鏡頭</button>
    <button data-mode="environment" style="padding:8px 12px; border-radius:8px;">後鏡頭</button>
  </div>


<!-- MediaPipe Pose + Camera Utilities（CDN） -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
  // ===== DOM =====
  const video     = document.getElementById("video");
  const canvas    = document.getElementById("canvas");
  const ctx       = canvas.getContext("2d");
  const startBtn  = document.getElementById("startBtn");
  const camSwitch = document.getElementById("camSwitch");
  // DOM HUD
  const elBpmNow  = document.getElementById("bpmNow");
  const elBpmAvg  = document.getElementById("bpmAvg");
  const elPress   = document.getElementById("pressCnt");

  // ===== MediaPipe 索引 =====
  const L_SHOULDER = 11, R_SHOULDER = 12;
  const L_ELBOW    = 13, R_ELBOW    = 14;
  const L_WRIST    = 15, R_WRIST    = 16;

  // ===== 平滑 =====
  const smoothStore = {};
  const SMOOTH_ALPHA = 0.65;
  function smoothPoint(idx, raw, w, h) {
    if (!raw) return null;
    const x = raw.x * w, y = raw.y * h;
    const p = smoothStore[idx];
    smoothStore[idx] = p
      ? { x: SMOOTH_ALPHA * p.x + (1 - SMOOTH_ALPHA) * x,
          y: SMOOTH_ALPHA * p.y + (1 - SMOOTH_ALPHA) * y }
      : { x, y };
    return smoothStore[idx];
  }

  // ===== 畫圖工具（在正確座標系下呼叫） =====
  function drawCircle(p, r, color) {
    if (!p) return;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fillStyle = color; ctx.fill();
  }
  function drawLine(a, b, w, color) {
    if (!a || !b) return;
    ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y);
    ctx.lineWidth = w; ctx.strokeStyle = color; ctx.stroke();
  }

  // ===== 相機/姿勢狀態  =====
  let pose = null; 
  let camera = null; 
  let currentFacing = "user";  // 預設前鏡頭

  let wristsOverlapped = false;   // 手腕交疊狀態（含遲滯避免抖動）
  let OVERLAP_ON_PX = 30; // 進入交疊門檻
  let OVERLAP_OFF_PX = 48; // 釋放門檻（> ON 的 1.6 倍）

  // HiDPI：把 canvas 內部像素對齊螢幕實體像素，但 CSS 尺寸維持 100vw/100dvh
const dpr = Math.max(1, window.devicePixelRatio || 1);
function syncCanvasToVideo() {
  const cw = canvas.clientWidth;   // 例如整個視窗寬（CSS px）
  const ch = canvas.clientHeight;  // 例如整個視窗高（CSS px）
  if (!cw || !ch) return;
  canvas.width  = Math.round(cw * dpr);   // 只設「內部像素」
  canvas.height = Math.round(ch * dpr);
  // 不要碰 canvas.style.width/height！讓它繼續是 100vw / 100dvh
}

  // ===== 指標計算（只在交疊期間更新）=====
  let prevWristsOverlapped = false;
  let yBuf = [], lastExtrema = null, peakTimes = [];
  let pressCount = 0, bpmNow = 0, bpmAvg30 = null;

  function resetMetrics() {
    yBuf = []; lastExtrema = null; peakTimes = [];
    pressCount = 0; bpmNow = 0; bpmAvg30 = null;
  }
  function bpmFromPeaks(times, N) {
    if (times.length < N) return 0;
    const t1 = times[times.length - N], t2 = times[times.length - 1];
    const span = t2 - t1, cycles = N - 1;
    return span > 0 ? (cycles / span) * 60 : 0;
  }

  // ===== 啟動 / 切換相機（Camera Utils） =====
  async function initPose(facingMode = "user") {
    if (camera && camera.stop) { try { await camera.stop(); } catch(_){} }
  // 建立 Pose（只建一次）
    if (!pose) {
      pose = new window.Pose({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`,
      });
      pose.setOptions({
        modelComplexity: 0,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      pose.onResults(onPoseResults);
    }

    camera = new Camera(video, {
      onFrame: async () => { await pose.send({ image: video }); },
      width: 640, height: 480, facingMode
    });

    video.addEventListener("loadeddata", () => { syncCanvasToVideo(); }, { once:true });

    await camera.start();

    // 視訊鏡像：只在前鏡頭
    const isMirrored = (facingMode === "user");
    video.classList.toggle("mirror", isMirrored);
    currentFacing = facingMode;

    // 依裝置解析度調整交疊門檻（用短邊 3% / 5%）
    const vw = video.videoWidth || 640, vh = video.videoHeight || 480;
    const base = Math.min(vw, vh);
    OVERLAP_ON_PX  = Math.max(24, base * 0.03);  // 至少 24px
    OVERLAP_OFF_PX = Math.max(36, base * 0.05);
  }

  // ===== 每幀繪製：只畫肩與手臂 + 交疊切換=====
  function onPoseResults(results) {
  const lm = results.poseLandmarks;
  if (!lm) return;

  // 先把 canvas 內部像素同步到目前視窗大小
  syncCanvasToVideo();

  // CSS 盒子大小（畫面實際看到的大小）
  const cw = canvas.clientWidth;
  const ch = canvas.clientHeight;

  // 影片原始尺寸（landmark 的座標基準）
  const vw = video.videoWidth || 640;
  const vh = video.videoHeight || 480;

  // object-fit: cover 的縮放倍率與置中位移（以 CSS 像素為單位）
  const s  = Math.max(cw / vw, ch / vh);      // 放大倍率
  const dx = (cw - vw * s) / 2;               // 置中後的左邊界
  const dy = (ch - vh * s) / 2;               // 置中後的上邊界

  // 設定座標系：先把 1 CSS px 映射到 dpr 實體像素，再套 cover 的位移＋縮放
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, cw, ch);
  ctx.translate(dx, dy);    // 先位移到影像左上角
  ctx.scale(s, s);          // 再按照 cover 的比例縮放

  // 若是前鏡頭，對「影像座標」做鏡像（注意：這裡用影片原始寬 vw）
  if (currentFacing === "user") {
    ctx.translate(vw, 0);
    ctx.scale(-1, 1);
  }

  // 之後所有繪圖請用「影片原始座標」，也就是 w=vw, h=vh
  const ls = smoothPoint(L_SHOULDER, lm[L_SHOULDER], vw, vh);
  const rs = smoothPoint(R_SHOULDER, lm[R_SHOULDER], vw, vh);
  const le = smoothPoint(L_ELBOW,    lm[L_ELBOW],    vw, vh);
  const re = smoothPoint(R_ELBOW,    lm[R_ELBOW],    vw, vh);
  const lw = smoothPoint(L_WRIST,    lm[L_WRIST],    vw, vh);
  const rw = smoothPoint(R_WRIST,    lm[R_WRIST],    vw, vh);

     // 手腕交疊（遲滯）手腕交疊判斷
    let mergedWrist = null;
    if (lw && rw) {
      const dist = Math.hypot(lw.x - rw.x, lw.y - rw.y);
      if (!wristsOverlapped && dist < OVERLAP_ON_PX) wristsOverlapped = true;
      else if (wristsOverlapped && dist > OVERLAP_OFF_PX) wristsOverlapped = false;
      if (wristsOverlapped) mergedWrist = { x:(lw.x+rw.x)/2, y:(lw.y+rw.y)/2 };
    }

    // 肩膀線（藍）
    drawCircle(ls, 6, "#00BFFF"); drawCircle(rs, 6, "#00BFFF");  // 點
    drawLine(ls, rs, 6, "#1E90FF");  // 肩膀連線（藍）

    // 手臂
    if (wristsOverlapped && mergedWrist) {
      drawLine(ls, mergedWrist, 8, "#FFC107");  // 交疊模式：黃線倒三角、單一手腕點
      drawLine(rs, mergedWrist, 8, "#FFC107");
      drawCircle(mergedWrist, 7, "#FFC107");
    } else {
      drawCircle(le, 5, "#FF4D4F"); drawCircle(re, 5, "#FF4D4F");
      drawCircle(lw, 5, "#FF4D4F"); drawCircle(rw, 5, "#FF4D4F");
      drawLine(ls, le, 6, "#FF3333"); drawLine(le, lw, 6, "#FF3333");
      drawLine(rs, re, 6, "#FF3333"); drawLine(re, rw, 6, "#FF3333");
    }

    // ---- 雙腕交疊 gating（與你現有 wristsOverlapped 同步）----
    // ===== 計速（只在交疊期間更新；分開凍結）=====
    const nowSec = Date.now() / 1000;
    // 交疊狀態切換：從「未交疊→交疊」時重置計算
    if (wristsOverlapped && !prevWristsOverlapped) resetMetrics();
    prevWristsOverlapped = wristsOverlapped;

    // ---- 只有在交疊期間才更新速率 ----
    if (wristsOverlapped && ls && rs) {

      // 兩肩平均 y（畫面座標，數值越大代表越往下）
      const avgY = (ls.y + rs.y) / 2;
      yBuf.push({ t: nowSec, y: avgY });
      if (yBuf.length > 3) yBuf.shift();

      // 用最近 3 筆判斷局部極值

      if (yBuf.length === 3) {  
        const [a, b, c] = yBuf;
        const isPeak   = (b.y > a.y && b.y > c.y);
        const isValley = (b.y < a.y && b.y < c.y);

        if (isPeak && lastExtrema === "valley") {
          // 完成一個「峰-谷-峰」循環 → 計一次
          pressCount++;
          peakTimes.push(b.t);
          // 即時速率：用最近 5 次峰算（不足 5 顯示 0）
          bpmNow  = bpmFromPeaks(peakTimes, 5);
          // 平均速率：用最近 30 次峰的時間跨度（不足 30 顯示 null）
          bpmAvg30 = peakTimes.length >= 30 ? bpmFromPeaks(peakTimes, 30) : null;
          lastExtrema = "peak";
        } else if (isPeak)   lastExtrema = "peak";
          else if (isValley) lastExtrema = "valley";
      }
    }

    // ===== 更新 HUD（DOM）===== 更新 HUD
  elBpmNow.textContent = bpmNow ? Math.round(bpmNow) : "--";
  elBpmAvg.textContent = (bpmAvg30 && bpmAvg30 > 0) ? Math.round(bpmAvg30) : "--";
  elPress.textContent  = pressCount;
  }

  // ===== 事件 =====
  startBtn.addEventListener("click", async () => {
    try { await initPose(currentFacing); startBtn.style.display = "none"; }
    catch (err) { alert("⚠️ 無法啟用鏡頭：" + err.message); console.error(err); }
  });

  camSwitch.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-mode]"); if (!btn) return;
    const mode = btn.getAttribute("data-mode");        // "user" | "environment"
    try { await initPose(mode); } catch (err) { console.error(err); }
  });
</script>


<div id="hud">
  <div class="row">即時速率：<span id="bpmNow">--</span> 次/分</div>
  <div class="row">平均速率：<span id="bpmAvg">--</span> 次/分</div>
  <div class="row">按壓次數：<span id="pressCnt">0</span> 次</div>
</div>

</body>
</html>
