<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CPR 偵測系統 V16.2（調參面板）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body{margin:0;overflow:hidden;background:#000;}
    video,canvas{position:absolute;top:0;left:0;width:100vw;height:100dvh;object-fit:cover;}
    .fit-contain video, .fit-contain canvas{ object-fit:contain; }
    .mirror{ transform:scaleX(-1); transform-origin:center; }
    #hud{
      position:absolute;top:0;left:0;
      padding:calc(env(safe-area-inset-top,0px)+12px) 16px 12px 16px;
      z-index:4;display:grid;gap:6px;background:rgba(0,0,0,.55);
      border-bottom-right-radius:14px;font:bold clamp(18px,2.4vw,36px)/1.1 sans-serif;color:#fff;pointer-events:none;
    }
    #hud .row{white-space:nowrap;}
    canvas{z-index:1;}
    #startBtn{
      position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);
      font-size:1.5em;padding:20px 30px;background:#28a745;color:#fff;border:0;border-radius:12px;cursor:pointer;z-index:2;
    }
    #camSwitch{position:absolute;top:12px;right:12px;z-index:10;display:flex;gap:8px;}
    #camSwitch button{padding:8px 12px;border-radius:8px;}

    /* 校準提示 */
    #calibHint{
      position:absolute;bottom:12px;left:50%;transform:translateX(-50%);
      background:rgba(0,0,0,.55);color:#fff;padding:8px 14px;border-radius:999px;
      font:600 14px/1 sans-serif;z-index:4;display:none;
    }

    /* ====== 右側調參面板 ====== */
    #panel{
      position:absolute;right:10px;top:70px;z-index:20;
      width:min(86vw,340px);max-height:80vh;overflow:auto;
      background:rgba(20,20,20,.88);color:#fff;border-radius:12px;padding:12px 12px 10px 12px;
      font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", sans-serif;
      box-shadow:0 6px 24px rgba(0,0,0,.45);backdrop-filter:blur(4px)
    }
    #panel h3{margin:0 0 8px 0;font-weight:800;font-size:16px}
    #panel .g{display:grid;grid-template-columns:1fr auto;gap:6px 10px;align-items:center;margin:10px 0}
    #panel label{opacity:.9}
    #panel input[type="range"]{width:100%}
    #panel .val{width:64px;text-align:right;opacity:.9}
    #panel small{opacity:.7}
    #panel .row{display:flex;gap:8px;margin-top:8px}
    #panel button{padding:6px 10px;border-radius:8px;border:0;background:#2e7d32;color:#fff;cursor:pointer}
    #panel button.secondary{background:#455a64}
    #panel .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    #togglePanel{
      position:absolute;right:10px;top:12px;z-index:20;border:0;border-radius:999px;
      background:#1f2937;color:#fff;padding:8px 12px;font-weight:700;cursor:pointer;opacity:.9
    }
    #togglePanel:hover{opacity:1}
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="hud">
    <div class="row">即時速率：<span id="bpmNow">--</span> 次/分</div>
    <div class="row">平均速率：<span id="bpmAvg">--</span> 次/分</div>
    <div class="row">按壓次數：<span id="pressCnt">0</span> 次</div>
    <div class="row">手腕距離：<span id="wristDist">--</span> px</div>
    <div class="row">交疊狀態：<span id="overlapState">--</span></div>
    <div class="row">頂角 α：<span id="apexDeg">--</span>°　基準 α₀：<span id="apexBase">--</span>°　Δα：<span id="apexDelta">--</span>°</div>
    <div class="row">rL：<span id="rL">--</span>%　rR：<span id="rR">--</span>%　基準 r₀：<span id="rBase">--</span>%</div>
    <div class="row">彎肘判定：<span id="bendState">--</span>　校準：<span id="calibState">--</span></div>
  </div>

  <button id="startBtn">開啟鏡頭</button>
  <button id="togglePanel">參數</button>

  <div id="camSwitch">
    <button data-mode="user">前鏡頭</button>
    <button data-mode="environment">後鏡頭</button>
    <button id="fitToggle">顯示：填滿</button>
  </div>

  <div id="calibHint">請維持直臂 0.8 秒進行校準…</div>

  <!-- ====== 調參面板 ====== -->
  <div id="panel" hidden>
    <h3>即時調參</h3>
    <small>變更即生效（會存到瀏覽器 localStorage；按「重設/儲存為預設」可管理）</small>

    <div class="g">
      <label>SMOOTH_ALPHA（平滑）</label>
      <input id="alpha" type="range" min="0.40" max="0.95" step="0.01"><span id="alphaVal" class="val"></span>
      <small>越大越穩、延遲越高</small><span></span>
    </div>

    <div class="g">
      <label>TAU_DEG（角度閾值，度）</label>
      <input id="tauDeg" type="range" min="4" max="14" step="1"><span id="tauDegVal" class="val"></span>
      <small>彎肘：Δα ≥ TAU_DEG</small><span></span>
    </div>

    <div class="g">
      <label>TAU_LEN（比例閾值，%）</label>
      <input id="tauLen" type="range" min="0" max="0.12" step="0.005"><span id="tauLenVal" class="val"></span>
      <small>彎肘：rMin ≤ r0*(1-TAU_LEN)</small><span></span>
    </div>

    <div class="grid2">
      <div class="g">
        <label>N_BEND_ON（連續幀數）</label>
        <input id="nOn" type="range" min="2" max="12" step="1"><span id="nOnVal" class="val"></span>
      </div>
      <div class="g">
        <label>N_BEND_OFF（連續幀數）</label>
        <input id="nOff" type="range" min="2" max="12" step="1"><span id="nOffVal" class="val"></span>
      </div>
    </div>

    <div class="g">
      <label>HYST_DEG（解除遲滯，度）</label>
      <input id="hystDeg" type="range" min="1" max="6" step="1"><span id="hystDegVal" class="val"></span>
      <small>越大越不易解除彎肘</small><span></span>
    </div>

    <div class="g">
      <label>CALI_SEC（校準秒數）</label>
      <input id="caliSec" type="range" min="0.4" max="1.2" step="0.1"><span id="caliSecVal" class="val"></span>
    </div>

    <hr style="border-color:#333;opacity:.6;margin:8px 0">

    <div class="g">
      <label>modelComplexity</label>
      <input id="mcx" type="range" min="0" max="2" step="1"><span id="mcxVal" class="val"></span>
      <small>0=快 / 1=較準 / 2=最準最慢</small><span></span>
    </div>
    <div class="g">
      <label>minDetectionConfidence</label>
      <input id="mdc" type="range" min="0.3" max="0.9" step="0.05"><span id="mdcVal" class="val"></span>
    </div>
    <div class="g">
      <label>minTrackingConfidence</label>
      <input id="mtc" type="range" min="0.3" max="0.9" step="0.05"><span id="mtcVal" class="val"></span>
    </div>

    <div class="row">
      <button id="resetBtn" class="secondary">重設為建議值</button>
      <button id="saveBtn">儲存為預設</button>
    </div>
  </div>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  // =================== 保留主體結構，僅把常數改為可調變數 ===================

  // DOM
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const camSwitch = document.getElementById('camSwitch');
  const fitToggle = document.getElementById('fitToggle');
  const elBpmNow = document.getElementById('bpmNow');
  const elBpmAvg = document.getElementById('bpmAvg');
  const elPress  = document.getElementById('pressCnt');
  const elWristDist = document.getElementById('wristDist');
  const elOverlap   = document.getElementById('overlapState');
  const elApexDeg   = document.getElementById('apexDeg');
  const elApexBase  = document.getElementById('apexBase');
  const elApexDelta = document.getElementById('apexDelta');
  const elrL        = document.getElementById('rL');
  const elrR        = document.getElementById('rR');
  const elrBase     = document.getElementById('rBase');
  const elBendState = document.getElementById('bendState');
  const elCalibState= document.getElementById('calibState');
  const calibHint   = document.getElementById('calibHint');

  // 參數（可從 localStorage 載入）
  const DEFAULTS = {
    SMOOTH_ALPHA: 0.70,
    TAU_DEG: 8,
    HYST_DEG: 3,
    TAU_LEN: 0.06,
    N_BEND_ON: 6,
    N_BEND_OFF: 6,
    CALI_SEC: 0.8,
    modelComplexity: 0,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  };
  const LS_KEY = 'cpr_cfg_v162';
  const cfg = Object.assign({}, DEFAULTS, JSON.parse(localStorage.getItem(LS_KEY) || '{}'));

  // Pose 索引
  const L_SHOULDER=11,R_SHOULDER=12,L_ELBOW=13,R_ELBOW=14,L_WRIST=15,R_WRIST=16;

  // 平滑（改成 let，供面板即時更新）
  const smoothStore={};
  let SMOOTH_ALPHA = cfg.SMOOTH_ALPHA;
  function smoothPoint(i,raw,w,h){
    if(!raw) return null;
    const x=raw.x*w, y=raw.y*h, p=smoothStore[i];
    return smoothStore[i]= p?{x:SMOOTH_ALPHA*p.x+(1-SMOOTH_ALPHA)*x,
                              y:SMOOTH_ALPHA*p.y+(1-SMOOTH_ALPHA)*y}:{x,y};
  }

  function drawCircle(p,r,c){ if(!p) return; ctx.beginPath();ctx.arc(p.x,p.y,r,0,Math.PI*2);ctx.fillStyle=c;ctx.fill();}
  function drawLine(a,b,w,c){ if(!a||!b) return; ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.lineTo(b.x,b.y);ctx.lineWidth=w;ctx.strokeStyle=c;ctx.stroke();}
  function dist(a,b){ return (!a||!b)?NaN:Math.hypot(a.x-b.x,a.y-b.y); }
  function angleABC(a,b,c){
    if(!a||!b||!c) return NaN;
    const v1={x:a.x-b.x,y:a.y-b.y}, v2={x:c.x-b.x,y:c.y-b.y};
    const dot=v1.x*v2.x+v1.y*v2.y, n1=Math.hypot(v1.x,v1.y), n2=Math.hypot(v2.x,v2.y);
    if(n1===0||n2===0) return NaN;
    let cos=dot/(n1*n2); cos=Math.min(1,Math.max(-1,cos));
    return Math.acos(cos)*180/Math.PI;
  }
  const clamp=(x,a,b)=>Math.min(b,Math.max(a,x));

  // 狀態
  let pose=null, camera=null, currentFacing='user';
  let wristsOverlapped=false; 
  let fitMode='cover';
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  function syncCanvasToVideo(){
    const cw=canvas.clientWidth, ch=canvas.clientHeight;
    if(!cw||!ch) return;
    canvas.width = Math.round(cw*dpr);
    canvas.height= Math.round(ch*dpr);
  }

  // 計速
  let prevWristsOverlapped=false, yBuf=[], lastExtrema=null, peakTimes=[];
  let pressCount=0, bpmNow=0, bpmAvg30=null;
  function resetMetrics(){ yBuf=[]; lastExtrema=null; peakTimes=[]; pressCount=0; bpmNow=0; bpmAvg30=null; }
  function bpmFromPeaks(t,N){ if(t.length<N) return 0; const span=t[t.length-1]-t[t.length-N]; return span>0?((N-1)/span)*60:0; }

  // 彎肘判定 / 校準（改採 cfg）
  let CALI_SEC   = cfg.CALI_SEC;
  let TAU_DEG    = cfg.TAU_DEG;
  let HYST_DEG   = cfg.HYST_DEG;
  let TAU_LEN    = cfg.TAU_LEN;
  let N_BEND_ON  = cfg.N_BEND_ON;
  let N_BEND_OFF = cfg.N_BEND_OFF;

  let OVERLAP_ON_PX=80, OVERLAP_OFF_PX=100;
  let calibCollect=false, calibEndTime=0;
  let alphaSamples=[], rMinSamples=[];
  let alpha0=null, r0=null;
  let bent=false, bendOnFrames=0, bendOffFrames=0;
  let overlapReleaseTime = 0;

  function startCalibrationWindow(){
    calibCollect=true;
    calibEndTime = performance.now()/1000 + CALI_SEC;
    alphaSamples.length=0; rMinSamples.length=0;
    calibHint.style.display='block';
    elCalibState.textContent = '蒐集中';
  }
  function finishCalibrationIfReady(now){
    if(!calibCollect || now < calibEndTime) return false;
    calibCollect=false;
    calibHint.style.display='none';
    if(alphaSamples.length>0 && rMinSamples.length>0){
      const m = arr => { const a=[...arr].sort((x,y)=>x-y); const mid=Math.floor(a.length/2); return (a.length%2)?a[mid]:(a[mid-1]+a[mid])/2; };
      alpha0 = m(alphaSamples); r0 = m(rMinSamples);
      elCalibState.textContent = '完成';
      return true;
    }else{ elCalibState.textContent = '不足'; return false; }
  }

  function onPoseResults(results){
    const lm = results.poseLandmarks; if(!lm) return;
    syncCanvasToVideo();
    const cw=canvas.clientWidth, ch=canvas.clientHeight;
    const vw=video.videoWidth||640, vh=video.videoHeight||480;
    const s  = (fitMode==='cover') ? Math.max(cw/vw, ch/vh) : Math.min(cw/vw, ch/vh);
    const dx = (cw - vw*s)/2, dy = (ch - vh*s)/2;

    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,cw,ch);
    ctx.translate(dx,dy); ctx.scale(s,s);
    if(currentFacing==='user'){ ctx.translate(vw,0); ctx.scale(-1,1); }

    const ls=smoothPoint(L_SHOULDER,lm[L_SHOULDER],vw,vh);
    const rs=smoothPoint(R_SHOULDER,lm[R_SHOULDER],vw,vh);
    const le=smoothPoint(L_ELBOW,   lm[L_ELBOW],   vw,vh);
    const re=smoothPoint(R_ELBOW,   lm[R_ELBOW],   vw,vh);
    const lw=smoothPoint(L_WRIST,   lm[L_WRIST],   vw,vh);
    const rw=smoothPoint(R_WRIST,   lm[R_WRIST],   vw,vh);

    // 交疊判斷（遲滯）
    let merged=null;
    if (lw && rw) {
      const d = Math.hypot(lw.x - rw.x, lw.y - rw.y);
      elWristDist.textContent = d.toFixed(1);
      elOverlap.textContent   = wristsOverlapped ? '交疊中' : '分開';

      if (!wristsOverlapped && d < OVERLAP_ON_PX) {
        wristsOverlapped = true;
        startCalibrationWindow();
        bent=false; bendOnFrames=0; bendOffFrames=0;
      } else if (wristsOverlapped && d > OVERLAP_OFF_PX) {
        if (!overlapReleaseTime) overlapReleaseTime = Date.now();
        if (Date.now() - overlapReleaseTime > 600) {
          wristsOverlapped = false; overlapReleaseTime = 0;
          calibCollect=false; calibHint.style.display='none';
        }
      } else { overlapReleaseTime = 0; }
      if (wristsOverlapped) merged = { x: (lw.x + rw.x) / 2, y: (lw.y + rw.y) / 2 };
    }

    // 畫肩/手臂
    drawCircle(ls,6,'#00BFFF'); drawCircle(rs,6,'#00BFFF'); drawLine(ls,rs,6,'#1E90FF');
    if(wristsOverlapped && merged){
      drawLine(ls,merged,8,'#FFC107'); drawLine(rs,merged,8,'#FFC107'); drawCircle(merged,7,'#FFC107');
    }else{
      drawCircle(le,5,'#FF4D4F'); drawCircle(re,5,'#FF4D4F');
      drawCircle(lw,5,'#FF4D4F'); drawCircle(rw,5,'#FF4D4F');
      drawLine(ls,le,6,'#FF3333'); drawLine(le,lw,6,'#FF3333');
      drawLine(rs,re,6,'#FF3333'); drawLine(re,rw,6,'#FF3333');
    }

    // 頂角 + 比例
    let alpha=NaN, rL=NaN, rR=NaN, rMin=NaN, S=NaN;
    if (wristsOverlapped && ls && rs && merged){
      S = dist(ls,rs);
      alpha = angleABC(ls, merged, rs);
      if (isFinite(S) && S>0){
        rL = dist(ls, merged)/S; rR = dist(rs, merged)/S;
        rMin = Math.min(rL, rR);
      }
      const t = performance.now()/1000;
      if (calibCollect && isFinite(alpha) && isFinite(rMin)){
        alphaSamples.push(alpha); rMinSamples.push(rMin);
      }
      finishCalibrationIfReady(t);
    }

    // HUD
    elApexDeg.textContent   = isFinite(alpha)?Math.round(alpha):'--';
    elApexBase.textContent  = isFinite(alpha0)?Math.round(alpha0):'--';
    const dAlpha = (isFinite(alpha)&&isFinite(alpha0)) ? (alpha - alpha0) : NaN;
    elApexDelta.textContent = isFinite(dAlpha)?dAlpha.toFixed(1):'--';
    elrL.textContent        = isFinite(rL)?Math.round(rL*100):'--';
    elrR.textContent        = isFinite(rR)?Math.round(rR*100):'--';
    elrBase.textContent     = isFinite(r0)?Math.round(r0*100):'--';

    // 彎肘判定（帶遲滯）
    if (wristsOverlapped && isFinite(alpha) && isFinite(alpha0) && isFinite(rMin) && isFinite(r0) && r0>0){
      const condBend    = (alpha - alpha0 >= TAU_DEG) && (rMin <= r0*(1 - TAU_LEN));
      const condRecover = (alpha - alpha0 <= TAU_DEG - HYST_DEG) && (rMin >= r0*(1 - TAU_LEN) + 0.02);
      if (!bent){
        if (condBend){ bendOnFrames++; if (bendOnFrames >= N_BEND_ON){ bent=true; bendOnFrames=0; } }
        else { bendOnFrames=0; }
      }else{
        if (condRecover){ bendOffFrames++; if (bendOffFrames >= N_BEND_OFF){ bent=false; bendOffFrames=0; } }
        else { bendOffFrames=0; }
      }
    }else{
      bent=false; bendOnFrames=0; bendOffFrames=0;
    }
    elBendState.textContent = bent ? '是（暫停計數）' : '否';
    elBendState.style.color = bent ? '#ff9800' : '#fff';
    elCalibState.textContent= (calibCollect ? '蒐集中' : (isFinite(alpha0)?'完成':'未開始'));

    // 峰谷計速（只在交疊期間）
    const now = Date.now()/1000;
    if(wristsOverlapped && !prevWristsOverlapped) resetMetrics();
    prevWristsOverlapped = wristsOverlapped;

    if(wristsOverlapped && ls && rs){
      const avgY=(ls.y+rs.y)/2;
      yBuf.push({t:now,y:avgY}); if(yBuf.length>3) yBuf.shift();
      if(yBuf.length===3){
        const [a,b,c]=yBuf, peak=(b.y>a.y && b.y>c.y), valley=(b.y<a.y && b.y<c.y);
        if(peak && lastExtrema==='valley'){
          if (!bent){
            pressCount++; peakTimes.push(b.t);
            bpmNow  = bpmFromPeaks(peakTimes,5);
            bpmAvg30= peakTimes.length>=30 ? bpmFromPeaks(peakTimes,30) : null;
          }
          lastExtrema='peak';
        }else if(peak){ lastExtrema='peak'; }
        else if(valley){ lastExtrema='valley'; }
      }
    }
    elBpmNow.textContent = bpmNow ? Math.round(bpmNow) : '--';
    elBpmAvg.textContent = (bpmAvg30 && bpmAvg30>0) ? Math.round(bpmAvg30) : '--';
    elPress.textContent  = pressCount;
  }

  // UI 事件
  startBtn.addEventListener('click', async ()=>{
    try{ await initPose(currentFacing); startBtn.style.display='none'; }
    catch(err){ alert('⚠️ 無法啟用鏡頭：'+err.message); console.error(err); }
  });
  camSwitch.addEventListener('click', async (e)=>{
    const btn=e.target.closest('button[data-mode],#fitToggle'); if(!btn) return;
    if(btn.id==='fitToggle'){
      fitMode = (fitMode==='cover') ? 'contain' : 'cover';
      document.body.classList.toggle('fit-contain', fitMode==='contain');
      btn.textContent = '顯示：' + (fitMode==='cover' ? '填滿' : '完整');
      return;
    }
    const mode = btn.getAttribute('data-mode'); try{ await initPose(mode); }catch(err){ console.error(err); }
  });

  async function initPose(facingMode='user'){
    if(camera && camera.stop){ try{ await camera.stop(); }catch(e){} }
    if(!pose){
      pose = new window.Pose({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}` });
      pose.setOptions({
        modelComplexity: cfg.modelComplexity,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: cfg.minDetectionConfidence,
        minTrackingConfidence: cfg.minTrackingConfidence
      });
      pose.onResults(onPoseResults);
    }else{
      // 若已存在，套用最新設定
      pose.setOptions({
        modelComplexity: cfg.modelComplexity,
        minDetectionConfidence: cfg.minDetectionConfidence,
        minTrackingConfidence: cfg.minTrackingConfidence
      });
    }

    camera = new Camera(video, {
      onFrame: async () => { await pose.send({ image: video }); },
      width: 1280, height: 720, facingMode
    });

    video.addEventListener('loadeddata', ()=>{ syncCanvasToVideo(); }, {once:true});
    await camera.start();

    video.classList.toggle('mirror', facingMode==='user');
    currentFacing = facingMode;

    const vw=video.videoWidth||640, vh=video.videoHeight||480, base=Math.min(vw,vh);
    OVERLAP_ON_PX = Math.max(60, base*0.12);
    OVERLAP_OFF_PX= Math.max(100, base*0.18);
  }

  // ====== 面板：綁定 ======
  const $ = sel => document.querySelector(sel);
  const bind = (id, get, set, fmt=x=>x) => {
    const input = $('#'+id), out = $('#'+id+'Val');
    input.value = get(); out.textContent = fmt(get());
    input.addEventListener('input', ()=>{ set(parseFloat(input.value)); out.textContent = fmt(parseFloat(input.value)); });
  };

  // 開/關面板
  const panel = $('#panel');
  $('#togglePanel').onclick = ()=> panel.hidden = !panel.hidden;

  function applyAndPersist(){
    localStorage.setItem(LS_KEY, JSON.stringify(cfg));
  }
  function resetDefaults(){
    Object.assign(cfg, DEFAULTS);
    // 同步可調變數
    SMOOTH_ALPHA = cfg.SMOOTH_ALPHA;
    TAU_DEG=cfg.TAU_DEG; HYST_DEG=cfg.HYST_DEG; TAU_LEN=cfg.TAU_LEN;
    N_BEND_ON=cfg.N_BEND_ON; N_BEND_OFF=cfg.N_BEND_OFF; CALI_SEC=cfg.CALI_SEC;
    // 重繪面板數值
    initPanelBindings(true);
    // 套用到 Pose（若已啟動）
    if(pose){ pose.setOptions({
      modelComplexity: cfg.modelComplexity,
      minDetectionConfidence: cfg.minDetectionConfidence,
      minTrackingConfidence: cfg.minTrackingConfidence
    });}
  }

  function initPanelBindings(force=false){
    bind('alpha', ()=>cfg.SMOOTH_ALPHA, v=>{ cfg.SMOOTH_ALPHA=v; SMOOTH_ALPHA=v; }, v=>v.toFixed(2));
    bind('tauDeg', ()=>cfg.TAU_DEG,     v=>{ cfg.TAU_DEG=v; TAU_DEG=v; }, v=>v.toFixed(0));
    bind('tauLen', ()=>cfg.TAU_LEN,     v=>{ cfg.TAU_LEN=v; TAU_LEN=v; }, v=>Math.round(v*100)+'%');
    bind('nOn',    ()=>cfg.N_BEND_ON,   v=>{ cfg.N_BEND_ON=v|0; N_BEND_ON=v|0; }, v=>v.toFixed(0));
    bind('nOff',   ()=>cfg.N_BEND_OFF,  v=>{ cfg.N_BEND_OFF=v|0; N_BEND_OFF=v|0; }, v=>v.toFixed(0));
    bind('hystDeg',()=>cfg.HYST_DEG,    v=>{ cfg.HYST_DEG=v; HYST_DEG=v; }, v=>v.toFixed(0));
    bind('caliSec',()=>cfg.CALI_SEC,    v=>{ cfg.CALI_SEC=v; CALI_SEC=v; }, v=>v.toFixed(1));
    bind('mcx',    ()=>cfg.modelComplexity, v=>{ cfg.modelComplexity=v|0; if(pose) pose.setOptions({modelComplexity: cfg.modelComplexity}); }, v=>v.toFixed(0));
    bind('mdc',    ()=>cfg.minDetectionConfidence, v=>{ cfg.minDetectionConfidence=v; if(pose) pose.setOptions({minDetectionConfidence: cfg.minDetectionConfidence}); }, v=>v.toFixed(2));
    bind('mtc',    ()=>cfg.minTrackingConfidence,  v=>{ cfg.minTrackingConfidence=v; if(pose) pose.setOptions({minTrackingConfidence: cfg.minTrackingConfidence}); }, v=>v.toFixed(2));
  }

  // 初始化面板
  initPanelBindings();
  $('#saveBtn').onclick = ()=>{ applyAndPersist(); alert('已儲存為預設（儲存在本裝置瀏覽器）'); };
  $('#resetBtn').onclick = ()=>{ resetDefaults(); };

  </script>

  <!-- 行動裝置 Console（若不需要可移除） -->
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
</body>
</html>
