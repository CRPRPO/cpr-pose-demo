<!DOCTYPE html>
<html>
  <head>
    <title>CPR 動作偵測與即時回饋</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      canvas, video {
        position: absolute;
        left: 0; top: 0;
        width: 100%;
        height: auto;
      }
      #feedback {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 2em;
        padding: 10px 20px;
        background-color: rgba(0,0,0,0.6);
        color: white;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
    <div id="feedback">準備中...</div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
      const videoElement = document.getElementById('video');
      const canvasElement = document.getElementById('canvas');
      const canvasCtx = canvasElement.getContext('2d');
      const feedback = document.getElementById('feedback');

      let previousY = null;
      let lastPressTime = Date.now();
      let pressCount = 0;

      const pose = new Pose.Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
      });

      pose.setOptions({
        modelComplexity: 0,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      pose.onResults((results) => {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.poseLandmarks) {
          for (const landmark of results.poseLandmarks) {
            canvasCtx.beginPath();
            canvasCtx.arc(landmark.x * canvasElement.width, landmark.y * canvasElement.height, 5, 0, 2 * Math.PI);
            canvasCtx.fillStyle = "red";
            canvasCtx.fill();
          }

          const wristY = results.poseLandmarks[15].y;
          const now = Date.now();

          if (previousY !== null) {
            const dy = previousY - wristY;
            if (dy > 0.05 && now - lastPressTime > 300) {
              pressCount++;
              lastPressTime = now;
            }
          }
          previousY = wristY;

          const elapsed = (now - lastPressTime) / 1000;
          const frequency = pressCount / (elapsed > 0 ? elapsed : 1) * 60;

          if (frequency > 110) {
            feedback.innerText = `太快了：${Math.round(frequency)} 次/分鐘`;
            feedback.style.backgroundColor = 'rgba(255,0,0,0.7)';
          } else if (frequency < 90) {
            feedback.innerText = `太慢了：${Math.round(frequency)} 次/分鐘`;
            feedback.style.backgroundColor = 'rgba(255,165,0,0.7)';
          } else {
            feedback.innerText = `完美節奏！${Math.round(frequency)} 次/分鐘`;
            feedback.style.backgroundColor = 'rgba(0,128,0,0.7)';
          }
        } else {
          feedback.innerText = "請對準身體";
          feedback.style.backgroundColor = 'rgba(0,0,0,0.5)';
        }
        canvasCtx.restore();
      });

      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await pose.send({ image: videoElement });
        },
        width: 640,
        height: 480
      });
      camera.start();
    </script>
  </body>
</html>
