<!DOCTYPE html>
<html>
<head>
  <title>CPR 偵測系統 V5.8</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    video, canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  object-fit: cover;         /* ← 讓兩者等比填滿，避免黑邊錯位 */
}
/* 刪掉原本 video { transform: scaleX(-1) } */
.mirror {
  transform: scaleX(-1);     /* ← 需要鏡像時再加這個 class */
  transform-origin: center;
}

    canvas {
      z-index: 1;
    }
    #startBtn {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5em;
      padding: 20px 30px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      z-index: 2;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
  <button id="startBtn">開啟鏡頭</button>
  <div id="camSwitch" style="
  position:absolute; top:12px; right:12px; z-index:3; display:flex; gap:8px;">
  <button data-mode="user" style="padding:8px 12px; border-radius:8px;">前鏡頭</button>
  <button data-mode="environment" style="padding:8px 12px; border-radius:8px;">後鏡頭</button>
</div>


<!-- MediaPipe Pose + Camera Utilities（CDN） -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
  // ---- 基本 DOM ----
  const video    = document.getElementById("video");
  const canvas   = document.getElementById("canvas");
  const ctx      = canvas.getContext("2d");
  const startBtn = document.getElementById("startBtn");
  const camSwitch= document.getElementById("camSwitch");

  // ---- 安全檢查 ----
  if (!window.Pose || !window.Camera) {
    console.error("MediaPipe 尚未載入");
  }

  // ---- MediaPipe 索引 ----
  const L_SHOULDER = 11, R_SHOULDER = 12;
  const L_ELBOW    = 13, R_ELBOW    = 14;
  const L_WRIST    = 15, R_WRIST    = 16;

  // ---- 平滑參數 ----
  const smoothStore = {};
  const SMOOTH_ALPHA = 0.65; // 稍微再穩一點
  function smoothPoint(idx, raw, w, h) {
    if (!raw) return null;
    const x = raw.x * w, y = raw.y * h;
    const p = smoothStore[idx];
    smoothStore[idx] = p
      ? { x: SMOOTH_ALPHA * p.x + (1 - SMOOTH_ALPHA) * x,
          y: SMOOTH_ALPHA * p.y + (1 - SMOOTH_ALPHA) * y }
      : { x, y };
    return smoothStore[idx];
  }

  // ---- 畫圖小工具（在鏡像座標系下呼叫）----
  function drawCircle(p, r, color) {
    if (!p) return;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
    ctx.fillStyle = color; ctx.fill();
  }
  function drawLine(a, b, w, color) {
    if (!a || !b) return;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.lineWidth = w; ctx.strokeStyle = color; ctx.stroke();
  }

  // ---- 相機/姿勢狀態 ----
  let pose = null;
  let camera = null;
  let currentFacing = "user";          // 預設前鏡頭

  // 手腕交疊狀態（含遲滯避免抖動）
  let wristsOverlapped = false;
  let OVERLAP_ON_PX = 30;              // 進入交疊門檻
  let OVERLAP_OFF_PX = 48;             // 釋放門檻（> ON 的 1.6 倍）

  // ---- 啟動/切換相機（Camera Utils）----
  async function initPose(facingMode = "user") {
    // 停掉舊相機
    if (camera && camera.stop) {
      try { await camera.stop(); } catch (e) { console.warn(e); }
    }

    // 建立 Pose（只建一次）
    if (!pose) {
      pose = new window.Pose({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`,
      });
      pose.setOptions({
        modelComplexity: 0,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });
      pose.onResults(onPoseResults);
    }

    // 依裝置解析度調整交疊門檻（用短邊 3% / 5%）
    const vw = video.videoWidth  || 640;
    const vh = video.videoHeight || 480;
    const base = Math.min(vw, vh);
    OVERLAP_ON_PX  = Math.max(24, base * 0.03); // 至少 24px
    OVERLAP_OFF_PX = Math.max(36, base * 0.05);

    // 重新啟動 Camera
    camera = new Camera(video, {
      onFrame: async () => { await pose.send({ image: video }); },
      width: 640,
      height: 480,
      facingMode, // "user" or "environment"
    });

    video.addEventListener("loadeddata", () => {
      if (video.videoWidth && video.videoHeight) {
        canvas.width  = video.videoWidth;
        canvas.height = video.videoHeight;
      }
    }, { once: true });

    await camera.start();
    // 依鏡頭決定是否鏡像顯示
    const isMirrored = (facingMode === "user");
    video.classList.toggle("mirror", isMirrored);
    currentFacing = facingMode;
  }

  // ---- 每幀結果：只畫肩與手臂 + 交疊切換 ----
  function onPoseResults(results) {
    const landmarks = results.poseLandmarks;
    if (!landmarks) return;

    const w = canvas.width  = video.videoWidth  || canvas.width;
    const h = canvas.height = video.videoHeight || canvas.height;

    ctx.save();
    ctx.clearRect(0, 0, w, h);

   // 只有前鏡頭才鏡像，讓線條與影片一致
    const isMirrored = (currentFacing === "user");
    if (isMirrored) {
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
    }

    // 平滑後座標
    const ls = smoothPoint(L_SHOULDER, landmarks[L_SHOULDER], w, h);
    const rs = smoothPoint(R_SHOULDER, landmarks[R_SHOULDER], w, h);
    const le = smoothPoint(L_ELBOW,    landmarks[L_ELBOW],    w, h);
    const re = smoothPoint(R_ELBOW,    landmarks[R_ELBOW],    w, h);
    const lw = smoothPoint(L_WRIST,    landmarks[L_WRIST],    w, h);
    const rw = smoothPoint(R_WRIST,    landmarks[R_WRIST],    w, h);

    // 手腕交疊判斷（遲滯）
    let mergedWrist = null;
    if (lw && rw) {
      const dist = Math.hypot(lw.x - rw.x, lw.y - rw.y);
      if (!wristsOverlapped && dist < OVERLAP_ON_PX) {
        wristsOverlapped = true;
      } else if (wristsOverlapped && dist > OVERLAP_OFF_PX) {
        wristsOverlapped = false;
      }
      if (wristsOverlapped) mergedWrist = { x: (lw.x + rw.x)/2, y: (lw.y + rw.y)/2 };
    }

    // 點
    drawCircle(ls, 6, "#00BFFF");
    drawCircle(rs, 6, "#00BFFF");

    // 肩膀連線（藍）
    drawLine(ls, rs, 6, "#1E90FF");

    if (wristsOverlapped && mergedWrist) {
      // 交疊模式：黃線倒三角、單一手腕點
      drawLine(ls, mergedWrist, 8, "#FFC107");
      drawLine(rs, mergedWrist, 8, "#FFC107");
      drawCircle(mergedWrist, 7, "#FFC107");
      // 手肘可選擇顯示或隱藏，這裡改為隱藏更清楚
      // （若要顯示，把下面兩行解除註解）
      // drawCircle(le, 5, "#FFD54D");
      // drawCircle(re, 5, "#FFD54D");
    } else {
      // 一般模式：紅色手臂（肩→肘→腕），手腕各自顯示
      drawCircle(le, 5, "#FF4D4F"); drawCircle(re, 5, "#FF4D4F");
      drawCircle(lw, 5, "#FF4D4F"); drawCircle(rw, 5, "#FF4D4F");
      drawLine(ls, le, 6, "#FF3333"); drawLine(le, lw, 6, "#FF3333");
      drawLine(rs, re, 6, "#FF3333"); drawLine(re, rw, 6, "#FF3333");
    }

    ctx.restore();

    // ... 你原本的 ls/rs/le/re/lw/rw 取點

// ---- 雙腕交疊 gating（與你現有 wristsOverlapped 同步）----
const nowSec = Date.now() / 1000;

// 交疊狀態切換：從「未交疊→交疊」時重置計算
if (wristsOverlapped && !prevWristsOverlapped) {
  resetMetrics();
}
prevWristsOverlapped = wristsOverlapped;

// ---- 只有在交疊期間才更新速率 ----
if (wristsOverlapped && ls && rs) {
  // 兩肩平均 y（畫面座標，數值越大代表越往下）
  const avgY = (ls.y + rs.y) / 2;
  yBuf.push({ t: nowSec, y: avgY });
  if (yBuf.length > 3) yBuf.shift();

  // 用最近 3 筆判斷局部極值
  if (yBuf.length === 3) {
    const [a, b, c] = yBuf;
    const isPeak   = (b.y > a.y && b.y > c.y);
    const isValley = (b.y < a.y && b.y < c.y);

    if (isPeak && lastExtrema === 'valley') {
      // 完成一個「峰-谷-峰」循環 → 計一次
      pressCount++;
      peakTimes.push(b.t);

      // 即時速率：用最近 5 次峰算（不足 5 顯示 0）
      bpmNow = bpmFromPeaks(peakTimes, 5);

      // 平均速率：用最近 30 次峰的時間跨度（不足 30 顯示 null）
      bpmAvg30 = peakTimes.length >= 30 ? bpmFromPeaks(peakTimes, 30) : null;

      lastExtrema = 'peak';
    } else if (isPeak) {
      lastExtrema = 'peak';
    } else if (isValley) {
      lastExtrema = 'valley';
    }
  }
}

// =======（這裡是你原本的畫線程式，保持不變）=======
// …肩膀藍線、一般模式紅線 / 交疊模式黃線 …
// ================================================

ctx.restore();

// ---- 非鏡像 HUD：分開時數字凍結；再次交疊會重置為 0 ----
drawHUD();

    // 這裡（非鏡像區）可畫你的左上角 HUD
    ctx.fillStyle = "#fff";
    ctx.font = "bold 28px sans-serif";
    ctx.fillText("即時速率：xxx 次/分", 20, 40);
  }

  // ---- 啟動與切換事件 ----
  startBtn.addEventListener("click", async () => {
    try {
      await initPose(currentFacing);
      startBtn.style.display = "none";
    } catch (err) {
      alert("⚠️ 無法啟用鏡頭：" + err.message);
      console.error(err);
    }
  });

  // 點選切換鏡頭（啟動後也可即時切）
  camSwitch.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-mode]");
    if (!btn) return;
    const mode = btn.getAttribute("data-mode"); // "user" or "environment"
    try { await initPose(mode); } catch (err) { console.error(err); }
  });

  // ---- 速率與計數（僅雙腕交疊時運作；分開凍結；再次交疊歸零）----
let prevWristsOverlapped = false;
let yBuf = [];                  // 最近 3 筆肩膀平均 y
let lastExtrema = null;         // 'peak' | 'valley'
let peakTimes = [];             // 每次「峰」時間（秒）
let pressCount = 0;
let bpmNow = 0;                 // 以最近 5 次計算
let bpmAvg30 = null;            // 以最近 30 次計算（不足 30 顯示 '--'）

function resetMetrics() {
  yBuf = [];
  lastExtrema = null;
  peakTimes = [];
  pressCount = 0;
  bpmNow = 0;
  bpmAvg30 = null;
}

// 以最近 N 次峰值時間，換算 bpm
function bpmFromPeaks(times, N) {
  if (times.length < N) return 0;
  const t1 = times[times.length - N];
  const t2 = times[times.length - 1];
  const cycles = N - 1;                 // N 個峰有 N-1 個完整週期
  const span = t2 - t1;                 // 秒
  return span > 0 ? (cycles / span) * 60 : 0;
}

function drawHUD() {
  ctx.fillStyle = "rgba(0,0,0,0.65)";
  ctx.fillRect(12, 12, 420, 120);
  ctx.fillStyle = "#fff";
  ctx.font = "bold 28px sans-serif";
  ctx.fillText(`即時速率：${bpmNow ? Math.round(bpmNow) : '--'} 次/分`, 24, 52);
  ctx.fillText(`平均速率：${bpmAvg30 ? Math.round(bpmAvg30) : '--'} 次/分`, 24, 88);
  ctx.fillText(`按壓次數：${pressCount} 次`, 24, 124);
}

</script>


</body>
</html>
