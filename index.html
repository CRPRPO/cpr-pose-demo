<!DOCTYPE html>
<html>
<head>
  <title>CPR 偵測系統 V5.14-smooth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100dvh;
      object-fit: cover;
    }
    .mirror {
      transform: scaleX(-1);
      transform-origin: center;
    }
    #hud {
      position: absolute;
      top: 0; left: 0;
      padding: calc(env(safe-area-inset-top, 0px) + 12px) 16px 12px 16px;
      z-index: 4;
      display: grid;
      gap: 6px;
      background: rgba(0,0,0,0.55);
      border-bottom-right-radius: 14px;
      font: bold clamp(18px, 2.4vw, 36px) / 1.1 sans-serif;
      color: #fff;
      pointer-events: none;
    }
    canvas { z-index: 1; }
    #startBtn {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5em;
      padding: 20px 30px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      z-index: 2;
    }
    #camSwitch {
      position:absolute; top:12px; right:12px; z-index:3; display:flex; gap:8px;
    }
    #camSwitch button {
      padding:8px 12px;
      border-radius:8px;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
  <button id="startBtn">開啟鏡頭</button>
  <div id="camSwitch">
    <button data-mode="user">前鏡頭</button>
    <button data-mode="environment">後鏡頭</button>
  </div>
  <div id="hud">
    <div class="row">即時速率:<span class="val" id="rateNow">0</span></div>
    <div class="row">平均速率:<span class="val" id="rateAvg">0</span></div>
    <div class="row">按壓次數:<span class="val" id="pressCount">0</span></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
  <script>
    // ===== 參數設定 =====
    const L_SHOULDER = 11, R_SHOULDER = 12;
    const L_ELBOW = 13, R_ELBOW = 14;
    const L_WRIST = 15, R_WRIST = 16;

    // (A) 平滑參數 - 越接近 1 越穩定（延遲感增加）
    const SMOOTH_ALPHA = 0.8;

    // 狀態變數
    let pose = null, camera = null, currentFacing = 'user';
    let wristsOverlapped = false;
    let fitMode = 'cover';

    // (C) 延遲解除交疊用
    let overlapReleaseTime = 0;

    // 紀錄速率
    let pressTimes = [];
    const RATE_SAMPLE = 5;
    const AVG_SAMPLE = 30;

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("startBtn");
    const rateNowEl = document.getElementById("rateNow");
    const rateAvgEl = document.getElementById("rateAvg");
    const pressCountEl = document.getElementById("pressCount");

    const smoothStore = {};
    function smoothPoint(idx, raw, w, h) {
      if (!raw) return null;
      const x = raw.x * w;
      const y = raw.y * h;
      const prev = smoothStore[idx];
      if (!prev) {
        smoothStore[idx] = { x, y };
      } else {
        smoothStore[idx] = {
          x: SMOOTH_ALPHA * prev.x + (1 - SMOOTH_ALPHA) * x,
          y: SMOOTH_ALPHA * prev.y + (1 - SMOOTH_ALPHA) * y
        };
      }
      return smoothStore[idx];
    }

    function drawCircle(p, r, color) {
      if (!p) return;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }
    function drawLine(a, b, w, color) {
      if (!a || !b) return;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.lineWidth = w;
      ctx.strokeStyle = color;
      ctx.stroke();
    }

    async function initPose() {
      pose = new Pose.Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
      });
      pose.setOptions({
        modelComplexity: 0,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      pose.onResults(onPoseResults);
    }

    async function startCamera(facingMode) {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { exact: facingMode } }
      });
      video.srcObject = stream;
      currentFacing = facingMode;
      if (facingMode === 'user') {
        video.classList.add('mirror');
      } else {
        video.classList.remove('mirror');
      }
      const cam = new Camera(video, {
        onFrame: async () => { await pose.send({ image: video }); },
        width: 640, height: 480
      });
      cam.start();
    }

    startBtn.addEventListener("click", async () => {
      await initPose();
      await startCamera(currentFacing);
      startBtn.style.display = "none";
    });

    document.querySelectorAll('#camSwitch button').forEach(btn => {
      btn.addEventListener('click', async () => {
        await startCamera(btn.dataset.mode);
      });
    });

    function onPoseResults(results) {
      const landmarks = results.poseLandmarks;
      if (!landmarks) return;

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const w = canvas.width, h = canvas.height;

      ctx.clearRect(0, 0, w, h);
      ctx.save();
      if (currentFacing === 'user') {
        ctx.translate(w, 0);
        ctx.scale(-1, 1);
      }

      const ls = smoothPoint(L_SHOULDER, landmarks[L_SHOULDER], w, h);
      const rs = smoothPoint(R_SHOULDER, landmarks[R_SHOULDER], w, h);
      const le = smoothPoint(L_ELBOW, landmarks[L_ELBOW], w, h);
      const re = smoothPoint(R_ELBOW, landmarks[R_ELBOW], w, h);
      const lw = smoothPoint(L_WRIST, landmarks[L_WRIST], w, h);
      const rw = smoothPoint(R_WRIST, landmarks[R_WRIST], w, h);

      // (B) 門檻用比例計算
      const base = Math.min(w, h);
      const OVERLAP_ON_PX = Math.max(28, base * 0.05);
      const OVERLAP_OFF_PX = Math.max(42, base * 0.07);

      // 計算交疊狀態 + (C) 延遲解除
      let merged = null;
      if (lw && rw) {
        const dist = Math.hypot(lw.x - rw.x, lw.y - rw.y);
        if (!wristsOverlapped && dist < OVERLAP_ON_PX) {
          wristsOverlapped = true;
        } else if (wristsOverlapped && dist > OVERLAP_OFF_PX) {
          if (!overlapReleaseTime) overlapReleaseTime = Date.now();
          if (Date.now() - overlapReleaseTime > 200) {
            wristsOverlapped = false;
            overlapReleaseTime = 0;
          }
        } else {
          overlapReleaseTime = 0;
        }
        if (wristsOverlapped) {
          merged = { x: (lw.x + rw.x) / 2, y: (lw.y + rw.y) / 2 };
        }
      }

      // 繪製
      drawLine(ls, rs, 6, "#1E90FF");
      if (wristsOverlapped) {
        drawLine(ls, merged, 6, "#FFD700");
        drawLine(rs, merged, 6, "#FFD700");
        drawCircle(merged, 6, "#FFD700");
      } else {
        drawLine(ls, le, 6, "#FF3333");
        drawLine(le, lw, 6, "#FF3333");
        drawLine(rs, re, 6, "#FF3333");
        drawLine(re, rw, 6, "#FF3333");
        drawCircle(lw, 5, "#FF3333");
        drawCircle(rw, 5, "#FF3333");
      }
      drawCircle(ls, 6, "#00BFFF");
      drawCircle(rs, 6, "#00BFFF");
      drawCircle(le, 5, "#FF3333");
      drawCircle(re, 5, "#FF3333");

      ctx.restore();
    }
  </script>
</body>
</html>
