<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CPR 偵測系統 V16.3.3（調參面板）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body{margin:0;overflow:hidden;background:#000;}
    video,canvas{position:absolute;top:0;left:0;width:100vw;height:100dvh;object-fit:cover;}
    .fit-contain video, .fit-contain canvas{ object-fit:contain; }
    .mirror{ transform:scaleX(-1); transform-origin:center; }

    /* 左上 HUD */
    #hud{
      position:absolute;top:0;left:0;
      padding:calc(env(safe-area-inset-top,0px)+12px) 16px 12px 16px;
      z-index:4;display:grid;gap:6px;background:rgba(0,0,0,.55);
      border-bottom-right-radius:14px;font:bold clamp(18px,2.4vw,36px)/1.1 sans-serif;color:#fff;pointer-events:none;
    }
    #hud .row{white-space:nowrap;}

    canvas{z-index:1;}
    #startBtn{
      position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);
      font-size:1.5em;padding:20px 30px;background:#28a745;color:#fff;border:0;border-radius:12px;cursor:pointer;z-index:2;
    }

    /* 右上控制列 */
    #camSwitch{position:absolute;top:12px;right:12px;z-index:10;display:flex;gap:8px;}
    #camSwitch button{padding:8px 12px;border-radius:8px;}
    #fitToggle{padding:8px 12px;border-radius:8px;}

    /* 校準提示 */
    #calibHint{
      position:absolute;bottom:12px;left:50%;transform:translateX(-50%);
      background:rgba(0,0,0,.55);color:#fff;padding:8px 14px;border-radius:999px;
      font:600 14px/1 sans-serif;z-index:4;display:none;
    }

    /* ====== 右側調參面板 ====== */
    #panel{
      position:absolute;right:10px;top:70px;z-index:20;
      width:min(86vw,360px);max-height:80vh;overflow:auto;
      background:rgba(20,20,20,.88);color:#fff;border-radius:12px;padding:12px 12px 10px 12px;
      font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", sans-serif;
      box-shadow:0 6px 24px rgba(0,0,0,.45);backdrop-filter:blur(4px)
    }
    #panel h3{margin:0 0 8px 0;font-weight:800;font-size:16px}
    #panel .g{display:grid;grid-template-columns:1fr auto;gap:6px 10px;align-items:center;margin:10px 0}
    #panel label{opacity:.9}
    #panel input[type="range"]{width:100%}
    #panel .val{width:64px;text-align:right;opacity:.9}
    #panel small{opacity:.7}
    #panel .row{display:flex;gap:8px;margin-top:8px}
    #panel button{padding:6px 10px;border-radius:8px;border:0;background:#2e7d32;color:#fff;cursor:pointer}
    #panel button.secondary{background:#455a64}
    #panel .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}

    #togglePanel{
      position:absolute;right:10px;top:12px;z-index:20;border:0;border-radius:999px;
      background:#1f2937;color:#fff;padding:8px 12px;font-weight:700;cursor:pointer;opacity:.9
    }
    #togglePanel:hover{opacity:1}
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="hud">
    <div class="row">即時速率：<span id="bpmNow">--</span> 次/分</div>
    <div class="row">平均速率：<span id="bpmAvg">--</span> 次/分</div>
    <div class="row">按壓次數：<span id="pressCnt">0</span> 次</div>
    <div class="row">手腕距離：<span id="wristDist">--</span> px</div>
    <div class="row">交疊狀態：<span id="overlapState">--</span></div>
    <div class="row">頂角 α：<span id="apexDeg">--</span>°　基準 α₀：<span id="apexBase">--</span>°　Δα：<span id="apexDelta">--</span>°</div>
    <div class="row">rL：<span id="rL">--</span>%　rR：<span id="rR">--</span>%　基準 r₀：<span id="rBase">--</span>%</div>
    <div class="row">彎肘判定：<span id="bendState">--</span>　校準：<span id="calibState">--</span></div>
  </div>

  <button id="startBtn">開啟鏡頭</button>
  <button id="togglePanel">參數</button>

  <div id="camSwitch">
    <button data-mode="user">前鏡頭</button>
    <button data-mode="environment">後鏡頭</button>
    <button id="fitToggle">顯示：填滿</button>
  </div>

  <div id="calibHint">請維持直臂 0.8 秒進行校準…</div>

  <!-- ====== 調參面板 ====== -->
  <div id="panel" hidden>
    <h3>即時調參</h3>
    <small>滑桿變更立即生效；按「儲存為預設」才會在重整後保留</small>

    <div class="g">
      <label>SMOOTH_ALPHA（平滑）</label>
      <input id="alpha" type="range" min="0.40" max="0.95" step="0.01"><span id="alphaVal" class="val"></span>
      <small>↑ 調大＝更穩但延遲↑；↓ 更即時但抖動↑</small><span></span>
    </div>

    <div class="g">
      <label>TAU_DEG（角度閾值，度）</label>
      <input id="tauDeg" type="range" min="4" max="14" step="1"><span id="tauDegVal" class="val"></span>
      <small>↑ 調大＝不易判彎（保守）；↓ 容易判彎（敏感）</small><span></span>
    </div>

    <div class="g">
      <label>TAU_LEN（比例閾值，%）</label>
      <input id="tauLen" type="range" min="0" max="0.12" step="0.005"><span id="tauLenVal" class="val"></span>
      <small>↑ 調大＝要縮短更多才算彎；↓ 小幅縮短也算彎</small><span></span>
    </div>

    <div class="grid2">
      <div class="g">
        <label>N_BEND_ON（連續幀數）</label>
        <input id="nOn" type="range" min="2" max="12" step="1"><span id="nOnVal" class="val"></span>
        <small>↑ 調大＝要維持更久才判彎</small><span></span>
      </div>
      <div class="g">
        <label>N_BEND_OFF（連續幀數）</label>
        <input id="nOff" type="range" min="2" max="12" step="1"><span id="nOffVal" class="val"></span>
        <small>↑ 調大＝更不易解除彎肘</small><span></span>
      </div>
    </div>

    <div class="g">
      <label>HYST_DEG（解除遲滯，度）</label>
      <input id="hystDeg" type="range" min="1" max="6" step="1"><span id="hystDegVal" class="val"></span>
      <small>↑ 調大＝解除需要更明顯的恢復（防抖更強）</small><span></span>
    </div>

    <div class="g">
      <label>CALI_SEC（校準秒數）</label>
      <input id="caliSec" type="range" min="0.4" max="1.2" step="0.1"><span id="caliSecVal" class="val"></span>
      <small>↑ 調大＝校準更穩但慢；↓ 更快開始但可能不穩</small><span></span>
    </div>

    <!-- 最小振幅（肩寬百分比） -->
    <div class="g">
      <label>AMP_MIN（最小振幅，占肩寬 %）</label>
      <input id="ampMinPct" type="range" min="1.0" max="3.0" step="0.1">
      <span id="ampMinPctVal" class="val"></span>
      <small>↑ 調大＝要更大位移才計數（更嚴格）；↓ 容易計數（更敏感）</small><span></span>
    </div>

    <hr style="border-color:#333;opacity:.6;margin:8px 0">

    <div class="g">
      <label>modelComplexity</label>
      <input id="mcx" type="range" min="0" max="2" step="1"><span id="mcxVal" class="val"></span>
      <small>0=快、2=最準（但慢）</small><span></span>
    </div>
    <div class="g">
      <label>minDetectionConfidence</label>
      <input id="mdc" type="range" min="0.3" max="0.9" step="0.05"><span id="mdcVal" class="val"></span>
      <small>↑ 調大＝初次偵測更嚴格</small><span></span>
    </div>
    <div class="g">
      <label>minTrackingConfidence</label>
      <input id="mtc" type="range" min="0.3" max="0.9" step="0.05"><span id="mtcVal" class="val"></span>
      <small>↑ 調大＝追蹤更穩但易掉點</small><span></span>
    </div>

    <hr style="border-color:#333;opacity:.6;margin:8px 0">

    <!-- 新增：交疊門檻與距離濾波 -->
    <div class="g">
      <label>overlapOnFactor（交疊 ON 係數）</label>
      <input id="olOn" type="range" min="0.08" max="0.28" step="0.01"><span id="olOnVal" class="val"></span>
      <small>↑ 調大＝更容易進入交疊（ON 門檻↑）</small><span></span>
    </div>
    <div class="g">
      <label>overlapOffFactor（交疊 OFF 係數）</label>
      <input id="olOff" type="range" min="0.16" max="0.36" step="0.01"><span id="olOffVal" class="val"></span>
      <small>↑ 調大＝更不容易被拆開（OFF 門檻↑）</small><span></span>
    </div>
    <div class="g">
      <label>wristEmaAlpha（手腕距離 EMA α）</label>
      <input id="wema" type="range" min="0.60" max="0.95" step="0.01"><span id="wemaVal" class="val"></span>
      <small>↑ 調大＝更穩但反應慢；↓ 更快進入/離開交疊</small><span></span>
    </div>

    <div class="row">
      <button id="resetBtn" class="secondary">重設為建議值</button>
      <button id="saveBtn">儲存為預設</button>
    </div>
  </div>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  // =================== 主體結構（加上面板與穩定化） ===================

  // DOM
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const camSwitch = document.getElementById('camSwitch');
  const fitToggle = document.getElementById('fitToggle');
  const elBpmNow = document.getElementById('bpmNow');
  const elBpmAvg = document.getElementById('bpmAvg');
  const elPress  = document.getElementById('pressCnt');
  const elWristDist = document.getElementById('wristDist');
  const elOverlap   = document.getElementById('overlapState');
  const elApexDeg   = document.getElementById('apexDeg');
  const elApexBase  = document.getElementById('apexBase');
  const elApexDelta = document.getElementById('apexDelta');
  const elrL        = document.getElementById('rL');
  const elrR        = document.getElementById('rR');
  const elrBase     = document.getElementById('rBase');
  const elBendState = document.getElementById('bendState');
  const elCalibState= document.getElementById('calibState');
  const calibHint   = document.getElementById('calibHint');

  // 建議預設 + localStorage 載入
  const DEFAULTS = {
    SMOOTH_ALPHA: 0.70,
    TAU_DEG: 8,
    HYST_DEG: 3,
    TAU_LEN: 0.06,
    ampMinPct: 1.5,   // 新增：最小振幅（％，預設 1.5）
    N_BEND_ON: 6,
    N_BEND_OFF: 6,
    CALI_SEC: 0.8,
    modelComplexity: 0,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5,
    overlapOnFactor: 0.16,   // ↑ 更容易進入交疊
    overlapOffFactor: 0.24,  // ↑ 更不容易被拆開
    wristEmaAlpha: 0.80      // ↑ 更穩但反應慢
  };
  const LS_KEY = 'cpr_cfg_v163';
  const cfg = Object.assign({}, DEFAULTS, JSON.parse(localStorage.getItem(LS_KEY) || '{}'));

  // 節點索引
  const L_SHOULDER=11,R_SHOULDER=12,L_ELBOW=13,R_ELBOW=14,L_WRIST=15,R_WRIST=16;

  // 平滑（關節）
  const smoothStore={};
  let SMOOTH_ALPHA = cfg.SMOOTH_ALPHA;
  function smoothPoint(i,raw,w,h){
    if(!raw) return null;
    const x=raw.x*w, y=raw.y*h, p=smoothStore[i];
    return smoothStore[i]= p
      ? {x:SMOOTH_ALPHA*p.x+(1-SMOOTH_ALPHA)*x, y:SMOOTH_ALPHA*p.y+(1-SMOOTH_ALPHA)*y}
      : {x,y};
  }

  // 小工具
  function drawCircle(p,r,c){ if(!p) return; ctx.beginPath();ctx.arc(p.x,p.y,r,0,Math.PI*2);ctx.fillStyle=c;ctx.fill();}
  function drawLine(a,b,w,c){ if(!a||!b) return; ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.lineTo(b.x,b.y);ctx.lineWidth=w;ctx.strokeStyle=c;ctx.stroke();}
  function dist(a,b){ return (!a||!b)?NaN:Math.hypot(a.x-b.x,a.y-b.y); }
  function angleABC(a,b,c){
    if(!a||!b||!c) return NaN;
    const v1={x:a.x-b.x,y:a.y-b.y}, v2={x:c.x-b.x,y:c.y-b.y};
    const dot=v1.x*v2.x+v1.y*v2.y, n1=Math.hypot(v1.x,v1.y), n2=Math.hypot(v2.x,v2.y);
    if(n1===0||n2===0) return NaN;
    let cos=dot/(n1*n2); cos=Math.min(1,Math.max(-1,cos));
    return Math.acos(cos)*180/Math.PI;
  }
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  function syncCanvasToVideo(){
    const cw=canvas.clientWidth, ch=canvas.clientHeight;
    if(!cw||!ch) return;
    canvas.width = Math.round(cw*dpr);
    canvas.height= Math.round(ch*dpr);
  }

  // 狀態
  let pose=null, camera=null, currentFacing='user';
  let wristsOverlapped=false, fitMode='cover';
  let prevWristsOverlapped=false, yBuf=[], lastExtrema=null, peakTimes=[];
  let pressCount=0, bpmNow=0, bpmAvg30=null;
  let CALI_SEC   = cfg.CALI_SEC;
  let TAU_DEG    = cfg.TAU_DEG;
  let HYST_DEG   = cfg.HYST_DEG;
  let TAU_LEN    = cfg.TAU_LEN;
  let N_BEND_ON  = cfg.N_BEND_ON;
  let N_BEND_OFF = cfg.N_BEND_OFF;
  let OVERLAP_ON_PX=45, OVERLAP_OFF_PX=140; // 會在 initPose 用係數更新
  let calibCollect=false, calibEndTime=0;
  let alphaSamples=[], rMinSamples=[];
  let alpha0=null, r0=null;
  let bent=false, bendOnFrames=0, bendOffFrames=0;
  let overlapReleaseTime = 0;
  let dEma = null; // 手腕距離 EMA

  function resetMetrics(){ yBuf=[]; lastExtrema=null; peakTimes=[]; pressCount=0; bpmNow=0; bpmAvg30=null; }
  function bpmFromPeaks(t,N){ if(t.length<N) return 0; const span=t[t.length-1]-t[t.length-N]; return span>0?((N-1)/span)*60:0; }

  // 校準
  function startCalibrationWindow(){
    calibCollect=true;
    calibEndTime = performance.now()/1000 + CALI_SEC;
    alphaSamples.length=0; rMinSamples.length=0;
    calibHint.style.display='block';
    elCalibState.textContent = '蒐集中';
  }
  function finishCalibrationIfReady(now){
    if(!calibCollect || now < calibEndTime) return false;
    calibCollect=false; calibHint.style.display='none';
    if(alphaSamples.length>0 && rMinSamples.length>0){
      const m = arr => { const a=[...arr].sort((x,y)=>x-y); const mid=Math.floor(a.length/2); return (a.length%2)?a[mid]:(a[mid-1]+a[mid])/2; };
      alpha0 = m(alphaSamples); r0 = m(rMinSamples);
      elCalibState.textContent = '完成';
      return true;
    }else{ elCalibState.textContent = '不足'; return false; }
  }

  function onPoseResults(results){
    const lm = results.poseLandmarks; if(!lm) return;
    syncCanvasToVideo();

    const cw=canvas.clientWidth, ch=canvas.clientHeight;
    const vw=video.videoWidth||640, vh=video.videoHeight||480;
    const s  = (fitMode==='cover') ? Math.max(cw/vw, ch/vh) : Math.min(cw/vw, ch/vh);
    const dx = (cw - vw*s)/2, dy = (ch - vh*s)/2;

    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,cw,ch);
    ctx.translate(dx,dy); ctx.scale(s,s);
    if(currentFacing==='user'){ ctx.translate(vw,0); ctx.scale(-1,1); }

    const ls=smoothPoint(L_SHOULDER,lm[L_SHOULDER],vw,vh);
    const rs=smoothPoint(R_SHOULDER,lm[R_SHOULDER],vw,vh);
    const le=smoothPoint(L_ELBOW,   lm[L_ELBOW],   vw,vh);
    const re=smoothPoint(R_ELBOW,   lm[R_ELBOW],   vw,vh);
    const lw=smoothPoint(L_WRIST,   lm[L_WRIST],   vw,vh);
    const rw=smoothPoint(R_WRIST,   lm[R_WRIST],   vw,vh);

    // 手腕距離 EMA（用可調 α）
    if (lw && rw){
      const dRaw = Math.hypot(lw.x - rw.x, lw.y - rw.y);
      const a = cfg.wristEmaAlpha;                 // 0.60~0.95
      dEma = dEma==null ? dRaw : a*dEma + (1-a)*dRaw;
      elWristDist.textContent = dEma.toFixed(1);
    }else{
      elWristDist.textContent = '--';
    }

    // 交疊判斷（距離遲滯 + 可見度保護 + 0.9s 離開延遲）
    let merged=null;
    if (lw && rw) {
      const visOK = (lm[L_WRIST].visibility>0.6 && lm[R_WRIST].visibility>0.6);
      elOverlap.textContent   = wristsOverlapped ? '交疊中' : '分開';

      if (!wristsOverlapped && isFinite(dEma) && dEma < OVERLAP_ON_PX) {
        wristsOverlapped = true;
        startCalibrationWindow();
        bent=false; bendOnFrames=0; bendOffFrames=0;
      } else if (wristsOverlapped && isFinite(dEma) && dEma > OVERLAP_OFF_PX && visOK) {
        if (!overlapReleaseTime) overlapReleaseTime = Date.now();
        if (Date.now() - overlapReleaseTime > 900) {
          wristsOverlapped = false; overlapReleaseTime = 0;
          calibCollect=false; calibHint.style.display='none';
        }
      } else {
        overlapReleaseTime = 0;
      }

      if (wristsOverlapped) merged = { x: (lw.x + rw.x) / 2, y: (lw.y + rw.y) / 2 };
    }

    // 繪圖
    drawCircle(ls,6,'#00BFFF'); drawCircle(rs,6,'#00BFFF'); drawLine(ls,rs,6,'#1E90FF');
    if(wristsOverlapped && merged){
      drawLine(ls,merged,8,'#FFC107'); drawLine(rs,merged,8,'#FFC107'); drawCircle(merged,7,'#FFC107');
    }else{
      drawCircle(le,5,'#FF4D4F'); drawCircle(re,5,'#FF4D4F');
      drawCircle(lw,5,'#FF4D4F'); drawCircle(rw,5,'#FF4D4F');
      drawLine(ls,le,6,'#FF3333'); drawLine(le,lw,6,'#FF3333');
      drawLine(rs,re,6,'#FF3333'); drawLine(re,rw,6,'#FF3333');
    }

    // 頂角 + 比例（兩肩-合併手腕）
    let alpha=NaN, rL=NaN, rR=NaN, rMin=NaN, S=NaN;
    if (wristsOverlapped && ls && rs && merged){
      S = dist(ls,rs);
      alpha = angleABC(ls, merged, rs);
      if (isFinite(S) && S>0){
        rL = dist(ls, merged)/S; rR = dist(rs, merged)/S;
        rMin = Math.min(rL, rR);
      }
      const t = performance.now()/1000;
      if (calibCollect && isFinite(alpha) && isFinite(rMin)){
        alphaSamples.push(alpha); rMinSamples.push(rMin);
      }
      finishCalibrationIfReady(t);
    }

    // HUD
    elApexDeg.textContent   = isFinite(alpha)?Math.round(alpha):'--';
    elApexBase.textContent  = isFinite(alpha0)?Math.round(alpha0):'--';
    const dAlpha = (isFinite(alpha)&&isFinite(alpha0)) ? (alpha - alpha0) : NaN;
    elApexDelta.textContent = isFinite(dAlpha)?dAlpha.toFixed(1):'--';
    elrL.textContent        = isFinite(rL)?Math.round(rL*100):'--';
    elrR.textContent        = isFinite(rR)?Math.round(rR*100):'--';
    elrBase.textContent     = isFinite(r0)?Math.round(r0*100):'--';

    // 彎肘判定（帶遲滯）
    if (wristsOverlapped && isFinite(alpha) && isFinite(alpha0) && isFinite(rMin) && isFinite(r0) && r0>0){
      const condBend    = (alpha - alpha0 >= TAU_DEG) && (rMin <= r0*(1 - TAU_LEN));
      const condRecover = (alpha - alpha0 <= TAU_DEG - HYST_DEG) && (rMin >= r0*(1 - TAU_LEN) + 0.02);
      if (!bent){
        if (condBend){ bendOnFrames++; if (bendOnFrames >= N_BEND_ON){ bent=true; bendOnFrames=0; } }
        else { bendOnFrames=0; }
      }else{
        if (condRecover){ bendOffFrames++; if (bendOffFrames >= N_BEND_OFF){ bent=false; bendOffFrames=0; } }
        else { bendOffFrames=0; }
      }
    }else{
      bent=false; bendOnFrames=0; bendOffFrames=0;
    }
    elBendState.textContent = bent ? '是（暫停計數）' : '否';
    elBendState.style.color = bent ? '#ff9800' : '#fff';
    elCalibState.textContent= (calibCollect ? '蒐集中' : (isFinite(alpha0)?'完成':'未開始'));

    // 峰谷計速（交疊期間）
    const now = Date.now()/1000;
    if(wristsOverlapped && !prevWristsOverlapped) resetMetrics();
    prevWristsOverlapped = wristsOverlapped;

    if (wristsOverlapped && ls && rs) {
      const avgY = (ls.y + rs.y) / 2;
      yBuf.push({ t: now, y: avgY });
      if (yBuf.length > 5) yBuf.shift();

      if (yBuf.length === 5) {
        const [p, q, b, c, d] = yBuf;
        const peak   = (b.y > q.y && b.y > c.y);
        const valley = (b.y < q.y && b.y < c.y);

        if (peak && lastExtrema === 'valley') {
          // 最小振幅門檻（肩寬 1.5%）
          const S = dist(ls, rs);
          const AMP_MIN = S * (cfg.ampMinPct / 100); // 用面板設定的百分比
          const amp = Math.abs(b.y - q.y);
          if (!(isFinite(S) && amp >= AMP_MIN)) {
            lastExtrema = 'peak';
            return; // 振幅太小，視為雜訊
          }


          // 不應期 / 合理頻率
          const MIN_INTERVAL = 0.30;
          const MAX_INTERVAL = 1.20;
          const lastT = peakTimes.length ? peakTimes[peakTimes.length - 1] : 0;
          const dt = b.t - lastT;
          if (peakTimes.length && (dt < MIN_INTERVAL || dt > MAX_INTERVAL)) { lastExtrema = 'peak'; return; }

          if (!bent) {
            pressCount++;
            peakTimes.push(b.t);
            bpmNow   = bpmFromPeaks(peakTimes, 5);
            bpmAvg30 = peakTimes.length >= 30 ? bpmFromPeaks(peakTimes, 30) : null;
          }
          lastExtrema = 'peak';
        } else if (peak) {
          lastExtrema = 'peak';
        } else if (valley) {
          lastExtrema = 'valley';
        }
      }
    }

    // HUD 更新
    elBpmNow.textContent = bpmNow ? Math.round(bpmNow) : '--';
    elBpmAvg.textContent = (bpmAvg30 && bpmAvg30>0) ? Math.round(bpmAvg30) : '--';
    elPress.textContent  = pressCount;
  } // onPoseResults end

  // UI
  document.getElementById('togglePanel').onclick = ()=>{
    const p = document.getElementById('panel'); p.hidden = !p.hidden;
  };
  startBtn.addEventListener('click', async ()=>{
    try{ await initPose(currentFacing); startBtn.style.display='none'; }
    catch(err){ alert('⚠️ 無法啟用鏡頭：'+err.message); console.error(err); }
  });
  camSwitch.addEventListener('click', async (e)=>{
    const btn=e.target.closest('button[data-mode],#fitToggle'); if(!btn) return;
    if(btn.id==='fitToggle'){
      const body=document.body;
      const fitModeNow = body.classList.toggle('fit-contain');
      fitMode = fitModeNow ? 'contain' : 'cover';
      btn.textContent = '顯示：' + (fitMode==='cover' ? '填滿' : '完整');
      return;
    }
    const mode = btn.getAttribute('data-mode');
    try{ await initPose(mode); }catch(err){ console.error(err); }
  });

  // 相機 / Pose
  async function initPose(facingMode='user'){
    if(camera && camera.stop){ try{ await camera.stop(); }catch(e){} }
    if(!pose){
      pose = new window.Pose({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}` });
      pose.setOptions({
        modelComplexity: cfg.modelComplexity,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: cfg.minDetectionConfidence,
        minTrackingConfidence: cfg.minTrackingConfidence
      });
      pose.onResults(onPoseResults);
    }else{
      pose.setOptions({
        modelComplexity: cfg.modelComplexity,
        minDetectionConfidence: cfg.minDetectionConfidence,
        minTrackingConfidence: cfg.minTrackingConfidence
      });
    }

    camera = new Camera(video, {
      onFrame: async () => { await pose.send({ image: video }); },
      width: 1280, height: 720, facingMode
    });

    video.addEventListener('loadeddata', ()=>{ syncCanvasToVideo(); }, {once:true});
    await camera.start();

    video.classList.toggle('mirror', facingMode==='user');
    currentFacing = facingMode;

    // 依影像短邊計算門檻（並套 px 下限）
    const vw=video.videoWidth||640, vh=video.videoHeight||480, base=Math.min(vw,vh);
    OVERLAP_ON_PX  = Math.max(45,  base*cfg.overlapOnFactor);
    OVERLAP_OFF_PX = Math.max(140, base*cfg.overlapOffFactor);
  }

  // ====== 面板綁定 ======
  const $ = sel => document.querySelector(sel);
  const bind = (id, get, set, fmt=x=>x) => {
    const input = $('#'+id), out = $('#'+id+'Val');
    input.value = get(); out.textContent = fmt(get());
    input.addEventListener('input', ()=>{
      const v = parseFloat(input.value);
      set(v);
      out.textContent = fmt(v);
    });
  };

  function applyAndPersist(){ localStorage.setItem(LS_KEY, JSON.stringify(cfg)); }

  function resetDefaults(){
    Object.assign(cfg, DEFAULTS);
    // 同步即時變數
    SMOOTH_ALPHA = cfg.SMOOTH_ALPHA;
    TAU_DEG=cfg.TAU_DEG; HYST_DEG=cfg.HYST_DEG; TAU_LEN=cfg.TAU_LEN;
    N_BEND_ON=cfg.N_BEND_ON; N_BEND_OFF=cfg.N_BEND_OFF; CALI_SEC=cfg.CALI_SEC;
    // 更新 Pose（若已啟動）
    if(pose){ pose.setOptions({
      modelComplexity: cfg.modelComplexity,
      minDetectionConfidence: cfg.minDetectionConfidence,
      minTrackingConfidence: cfg.minTrackingConfidence
    });}
    initPanelBindings();
  }

  function initPanelBindings(){
    bind('alpha',  ()=>cfg.SMOOTH_ALPHA, v=>{ cfg.SMOOTH_ALPHA=v; SMOOTH_ALPHA=v; }, v=>v.toFixed(2));
    bind('tauDeg', ()=>cfg.TAU_DEG,      v=>{ cfg.TAU_DEG=v; TAU_DEG=v; }, v=>v.toFixed(0));
    bind('tauLen', ()=>cfg.TAU_LEN,      v=>{ cfg.TAU_LEN=v; TAU_LEN=v; }, v=>Math.round(v*100)+'%');
    bind('nOn',    ()=>cfg.N_BEND_ON,    v=>{ cfg.N_BEND_ON=v|0; N_BEND_ON=v|0; }, v=>v.toFixed(0));
    bind('nOff',   ()=>cfg.N_BEND_OFF,   v=>{ cfg.N_BEND_OFF=v|0; N_BEND_OFF=v|0; }, v=>v.toFixed(0));
    bind('hystDeg',()=>cfg.HYST_DEG,     v=>{ cfg.HYST_DEG=v; HYST_DEG=v; }, v=>v.toFixed(0));
    bind('caliSec',()=>cfg.CALI_SEC,     v=>{ cfg.CALI_SEC=v; CALI_SEC=v; }, v=>v.toFixed(1));

    bind('mcx',    ()=>cfg.modelComplexity, v=>{ cfg.modelComplexity=v|0; if(pose) pose.setOptions({modelComplexity: cfg.modelComplexity}); }, v=>v.toFixed(0));
    bind('mdc',    ()=>cfg.minDetectionConfidence, v=>{ cfg.minDetectionConfidence=v; if(pose) pose.setOptions({minDetectionConfidence: cfg.minDetectionConfidence}); }, v=>v.toFixed(2));
    bind('mtc',    ()=>cfg.minTrackingConfidence,  v=>{ cfg.minTrackingConfidence=v; if(pose) pose.setOptions({minTrackingConfidence: cfg.minTrackingConfidence}); }, v=>v.toFixed(2));

    // 新增：交疊門檻與距離 EMA
    bind('olOn',  ()=>cfg.overlapOnFactor,  v=>{ cfg.overlapOnFactor=v;  /* 門檻生效在下次 initPose；或這裡也可即時計算 */ }, v=>v.toFixed(2));
    bind('olOff', ()=>cfg.overlapOffFactor, v=>{ cfg.overlapOffFactor=v; /* 同上 */ }, v=>v.toFixed(2));
    bind('wema',  ()=>cfg.wristEmaAlpha,    v=>{ cfg.wristEmaAlpha=v; }, v=>v.toFixed(2));
    bind('ampMinPct', ()=>cfg.ampMinPct, v=>{ cfg.ampMinPct=v; }, v=>v.toFixed(1)+'%');

  }

  initPanelBindings();
  document.getElementById('saveBtn').onclick = ()=>{ applyAndPersist(); alert('已儲存為預設（本裝置瀏覽器）'); };
  document.getElementById('resetBtn').onclick = ()=>{ resetDefaults(); };
  </script>

  <!-- 行動裝置 Console（可移除） -->
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>eruda.init();</script>
</body>
</html>
