<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>CPR 鏡頭發送端</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: sans-serif;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #video {
      transform: scaleX(-1);
      display: none;
    }
    #side-label {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
      font-weight: bold;
      background: rgba(0,0,0,0.5);
      padding: 10px 20px;
      border-radius: 10px;
    }
    #status {
      position: absolute;
      bottom: 10px;
      right: 10px;
      font-size: 20px;
      color: #0f0;
    }
    #ready {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-size: 24px;
      color: white;
    }
    #error {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
      color: red;
      background: black;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="side-label">準備中...</div>
  <div id="status">速率偵測中...</div>
  <div id="ready">準備中...</div>
  <div id="error"></div>

  <script type="module">
    import { Pose } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3';

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const label = document.getElementById('side-label');
    const status = document.getElementById('status');
    const ready = document.getElementById('ready');
    const errorBox = document.getElementById('error');

    let detector;
    let lastWristY = null;
    let lastTimestamp = null;
    let rates = [];

    async function initCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' },
          audio: false
        });
        video.srcObject = stream;
        return new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.play();
            resolve();
          };
        });
      } catch (err) {
        errorBox.textContent = '鏡頭啟動失敗：' + err.message;
      }
    }

    async function initPose() {
      const vision = await Pose.createFromOptions(Pose.SupportedModels.BlazePose, {
        runtime: 'mediapipe',
        modelType: 'full',
        solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/pose'
      });
      return vision;
    }

    function drawLine(p1, p2) {
      ctx.beginPath();
      ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
      ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 5;
      ctx.stroke();
    }

    function drawPoint(p) {
      ctx.beginPath();
      ctx.arc(p.x * canvas.width, p.y * canvas.height, 6, 0, 2 * Math.PI);
      ctx.fillStyle = 'red';
      ctx.fill();
    }

    function detectSide(keypoints) {
      const left = keypoints.find(p => p.name === 'left_shoulder');
      const right = keypoints.find(p => p.name === 'right_shoulder');
      return left.score > right.score ? 'left' : 'right';
    }

    function smoothRate(rate) {
      rates.push(rate);
      if (rates.length > 6) rates.shift();
      const avg = rates.reduce((a, b) => a + b, 0) / rates.length;
      return Math.round(avg);
    }

    function updateRate(nowY, timestamp) {
      if (lastWristY !== null && lastTimestamp !== null) {
        const dy = nowY - lastWristY;
        const dt = (timestamp - lastTimestamp) / 1000; // 秒
        if (Math.abs(dy) > 0.02 && dt > 0.2) {
          const rate = 60 / dt;
          const smooth = smoothRate(rate);
          status.textContent = `速率：約 ${smooth} 下/分鐘`;
        }
      }
      lastWristY = nowY;
      lastTimestamp = timestamp;
    }

    async function render() {
      if (!detector) return;
      const pose = await detector.estimatePoses(video);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (pose && pose.length > 0) {
        const kps = pose[0].keypoints;
        const side = detectSide(kps);
        label.textContent = side === 'left' ? '左手' : '右手';

        const shoulder = kps.find(p => p.name === `${side}_shoulder`);
        const wrist = kps.find(p => p.name === `${side}_wrist`);
        const hip = kps.find(p => p.name === `${side}_hip`);

        if (shoulder && wrist && hip && shoulder.score > 0.5 && wrist.score > 0.5 && hip.score > 0.5) {
          drawPoint(shoulder);
          drawPoint(wrist);
          drawPoint(hip);
          drawLine(shoulder, wrist);
          drawLine(wrist, hip);
          updateRate(wrist.y, performance.now());
        }
      }
      requestAnimationFrame(render);
    }

    async function main() {
      await initCamera();
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      detector = await initPose();
      ready.textContent = '';
      render();
    }

    main();
  </script>
</body>
</html>
